# 1、两数之和



**题目：**

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。

方法一：通过哈希来解决

```c++
#include <iostream>
#include <map>
#include <vector>

using namespace std;

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        map<int,int> a;//建立hash表存放数组元素
        vector<int> b{-1,-1};//存放结果
        for(int i=0;i<nums.size();i++)
            a.insert(map<int,int>::value_type(nums[i],i));
        for(int i=0;i<nums.size();i++){
            //判断是否找到目标元素且目标元素不能是本身
            if(a.count(target-nums[i])>0&&(a[target-nums[i]]!=i)){
                b[0]=i;
                b[1]=a[target-nums[i]];
                break;
            }
        }
        return b;
    };
};
```

方法二：暴力循环
略~~~~





# 2、两数相加



**题目：**

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

**示例 1：**

![img](D:\Users\suyu\Pictures\Typora-picture\addtwonumber1.jpg)

```c
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807
```



**思路：**通过模拟竖式相加的过程即可求解，进位怎么解决是核心。

```c++
#include <iostream>
#include <vector>
using namespace std;

struct ListNode
{
    int val;
    ListNode* next;
    // 无参构造，val初始化为0，next初始化为null
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    // 有参构造
    ListNode(int x, ListNode* next) : val(x), next(next) {}
};

class Solution
{
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)
    {
        ListNode* addp = new ListNode(0);
        ListNode* addps = addp;

        while (l1 != nullptr || l2 != nullptr) {
            int val1 = 0, val2 = 0;
            if (l1 != nullptr)
                val1 = l1->val;

            if (l2 != nullptr)
                val2 = l2->val;
            int csum = 0;
            int sum = val1 + val2 + addp->val;

            addp->val = sum % 10;
            csum = sum / 10;

            if (l1 != nullptr)l1 = l1->next;
            if (l2 != nullptr)l2 = l2->next;
            
			//当需要进位时（csum>=1），l1或l2没遍历完时
            if (csum >= 1 || l1 != nullptr || l2 != nullptr) {
                if (csum >= 1)
                    addp->next = new ListNode(1);
                else
                    addp->next = new ListNode();
            }
            if (addp != nullptr)addp = addp->next;
        }
        return addps;
    }
};


int main() {

    return 0;
}
```





# 3、无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```c
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```c
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```c
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```



方法一：滑动窗口

```c++
#include <algorithm>
#include<string>
#include<iostream>
#include<unordered_set>

using namespace std;

class Solution {
public:
	int lengthOfLongestSubstring(string s) {
		unordered_set<char> look;
		auto l = 0;
		int ans = 0;
		int len = s.size();
		if (len == 0)
			return 0;
		//cout << s[l] << endl;
		for (int r = 0; r < len; ++r) {
			//look中有s[i]则while循环
			while (look.find(s[r]) != look.end()) {
				//窗口向右移动
				look.erase(s[l]);
				++l;
			}
			//(r-l+1)：窗口的大小，也就是最长子串的长度
			ans = max(ans, r - l + 1);
			look.insert(s[r]);
		}
		return ans;
	}
};

int main() {
	Solution st;
	string str = "pwwkew";
	int ans=st.lengthOfLongestSubstring(str);
	cout << ans;
	return 0;
}
```





# 4、(；´д｀)ゞ暂时不会





# 5、最长回文子串

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

**示例 1：**

```c
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```c
输入：s = "cbbd"
输出："bb"
```

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母组成



方法一：扩散法

```c
#include<iostream>
#include<ctime>
#include<vector>
#include<algorithm>
#include<fstream>

using namespace std;

class Solution {
private:
    //计算以left和right为中心的回文串长度
    int expendaroundcenter(string s, int left, int right){
        int L = left;
        int R = right;
        while (L >= 0 && R < s.length() && s[R] == s[L]){
            L--;
            R++;
        }
        return R - L - 1;
    }

public:
    string longestPalindrome(string s) {
        int len = s.size();
        if (len == 0 || len == 1)
            return s;
        int start = 0;//记录回文子串起始位置
        int end = 0;//记录回文子串终止位置
        int mlen = 0;//记录最大回文子串的长度
        for (int i = 0; i < len; i++){
            int len1 = expendaroundcenter(s, i, i);//一个元素为中心
            int len2 = expendaroundcenter(s, i, i + 1);//两个元素为中心
            mlen = max(max(len1, len2), mlen);

            if (mlen > end - start + 1){
                start = i - (mlen - 1) / 2;
                end = i + mlen / 2;
            }
        }
        return s.substr(start, mlen);
        //该函数的意思是获取从start开始长度为mlen长度的字符串
    }
};


int main() {
    //fbabadefghb
    Solution sol;
    string str = "cbbdb";
    //cout << str.substr(0, 2) << endl;
    string ans = sol.longestPalindrome(str);
    cout << ans << endl;
    cout << ans.size() << endl;
	return 0;
}
```







# 6、N字形变换

将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 `"PAYPALISHIRING"` 行数为 `3` 时，排列如下：

```c
P   A   H   N
A P L S I I G
Y   I   R
```

之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"PAHNAPLSIIGYIR"`。

请你实现这个将字符串进行指定行数变换的函数：

```c
string convert(string s, int numRows);
```

 

**示例 1：**

```c
输入：s = "PAYPALISHIRING", numRows = 3
输出："PAHNAPLSIIGYIR"
```

**示例 2：**

```c
输入：s = "PAYPALISHIRING", numRows = 4
输出："PINALSIGYAHRPI"
解释：
P     I    N
A   L S  I G
Y A   H R
P     I
```

**示例 3：**

```c
输入：s = "A", numRows = 1
输出："A"
```

 

**提示：**

- `1 <= s.length <= 1000`
- `s` 由英文字母（小写和大写）、`','` 和 `'.'` 组成
- `1 <= numRows <= 1000`



```c++
#include<iostream>
#include<ctime>
#include<vector>
#include<algorithm>
#include<fstream>

using namespace std;

class Solution {
public:
    string convert(string s, int numRows) {
        vector<string>z(numRows,"");
        string ans;
        //判断是否需要重新排列
        if (numRows > 1) {
            //间隔数
            int interval = numRows - 2;
            //循环周期
            int cir = numRows + numRows-2;
            int lenght = s.size();
            //循环排列
            for (int i = 1; i <= lenght; ++i) {
                //通过ccir记录排序规律
                int ccir = i % cir;
                //如果是竖列
                if (ccir <= numRows && ccir > 0) {
                    //只需要锁定行并将对应字母加到此行后即可
                    z.at(ccir - 1) += s[i - 1];
                }
                else {
                    //模cir（周期） != 0的情况
                    if (ccir != 0)
                        z.at(numRows - (ccir - numRows) - 1) += s[i - 1];
                    //模cir（周期） = 0的情况
                    else
                        z.at(1) += s[i - 1];
                }
            }
            for (auto it = z.begin(); it < z.end(); ++it) {
                //cout << *it << endl;
                ans += *it;
            }
            return ans;
        }
        else {
            return s;
        }
    }
};

/*
     行/下标
     ①      1        7       13
     ②      2     6  8    12 14  
     ③      3  5     9  11   15
     ④      4        10
     由于我们只需要关注行即可得到答案
     我们可以发现numRows=4时上图，（cir）周期为6，下标为（1,2,3,4）（7,8,9,10）模6都为（1,2,3,4）
     而像（5,6）（11,12）这样的需要特殊处理分为两种情况
     1、模cir（周期）!=0的情况
     2、模cir（周期） =0的情况，也就是n个周期的那个值
*/


int main() {
    Solution str;
    string ans=str.convert("PAYPALISHIRING",3);
    cout << ans;

	return 0;
}
```







# 7、整数反转

给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 `[−231, 231 − 1]` ，就返回 0。

**假设环境不允许存储 64 位整数（有符号或无符号）。**

 

**示例 1：**

```c
输入：x = 123
输出：321
```

**示例 2：**

```c
输入：x = -123
输出：-321
```

**示例 3：**

```c
输入：x = 120
输出：21
```

**示例 4：**

```c
输入：x = 0
输出：0
```



**提示：**

- `-231 <= x <= 231 - 1`

方法一：

```c++
#include<iostream>
#include<ctime>
#include<vector>
#include<algorithm>
#include<fstream>

using namespace std;

class Solution {
public:
	int reverse(int x) {
		int xx = x;
		int isend = -1;
		//扩大为long long，避免溢出
		long long ans = 0;
		int flag = 0;
		while (xx != 0) {
			isend = xx % 10;
			//通过flag标记是否为末尾零
			if (isend != 0 || flag != 0) {
				flag = 1;
				ans = ans + isend;
			}

			//判断顺序和乘10顺序很重要（先判断是否溢出再乘10）
			if (ans > 2147483647 || ans < -2147483648)
				return 0;
			else
				ans = ans * 10;

			xx = xx / 10;
		}
		return ans / 10;
	}
};

int main() {
	Solution ss;
	int ans = ss.reverse(1534236469);
	cout << ans;
	return 0;
}
```

方法二：

通过数组来存储每一位数字在反转成数，再判断是否越界

略~~~~







# 8、字符串转化整数（atoi）

请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 `atoi` 函数）。

函数 `myAtoi(string s)` 的算法如下：

1. 读入字符串并丢弃无用的前导空格
2. 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
3. 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
4. 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 `0` 。必要时更改符号（从步骤 2 开始）。
5. 如果整数数超过 32 位有符号整数范围 `[−231, 231 − 1]` ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 `−231` 的整数应该被固定为 `−231` ，大于 `231 − 1` 的整数应该被固定为 `231 − 1` 。
6. 返回整数作为最终结果。

**注意：**

- 本题中的空白字符只包括空格字符 `' '` 。
- 除前导空格或数字后的其余字符串外，**请勿忽略** 任何其他字符。

 

**示例 1：**

```
输入：s = "42"
输出：42
解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："42"（读入 "42"）
           ^
解析得到整数 42 。
由于 "42" 在范围 [-231, 231 - 1] 内，最终结果为 42 。
```

**示例 2：**

```c
输入：s = "   -42"
输出：-42
解释：
第 1 步："   -42"（读入前导空格，但忽视掉）
            ^
第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步："   -42"（读入 "42"）
               ^
解析得到整数 -42 。
由于 "-42" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。
```

**示例 3：**

```c
输入：s = "4193 with words"
输出：4193
解释：
第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）
             ^
解析得到整数 4193 。
由于 "4193" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。
```

 

**提示：**

- `0 <= s.length <= 200`
- `s` 由英文字母（大写和小写）、数字（`0-9`）、`' '`、`'+'`、`'-'` 和 `'.'` 组成

```c++
#include<iostream>
#include<ctype.h>
#include<ctime>
#include<vector>
#include<algorithm>
#include<fstream>

using namespace std;

class Solution {
public:
    int myAtoi(string s) {
        int res = 0, bndry = INT_MAX / 10;
        int i = 0, sign = 1, length = s.size();
        if (length == 0) 
            return 0;
        //跳过空格字符
        while (s[i] == ' ') {
            if (++i == length) 
                return 0;
        }
		//符号判断
        if (s[i] == '-') 
            sign = -1;
        if (s[i] == '-' || s[i] == '+') 
            i++;

        for (int j = i; j < length; j++) {
            //当跳过空格和符号后首位不在0~9中就直接return 0
            if (s[j] < '0' || s[j] > '9')
                break;
            if (res > bndry || res == bndry && s[j] > '7')
                return sign == 1 ? INT_MAX : INT_MIN;
            res = res * 10 + (s[j] - '0');
        }
        return sign * res;
    }
};

int main() {
    
    Solution str_int;
    cout<<str_int.myAtoi(" + 0 123");

	return 0;
}
```







# 9、回文数字

给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

- 例如，`121` 是回文，而 `123` 不是。

 

**示例 1：**

```c
输入：x = 121
输出：true
```

**示例 2：**

```c
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3：**

```c
输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
```

 

**提示：**

- `-231 <= x <= 231 - 1`

方法一：转化为字符串

```c++
//方法一：
class Solution {
public:
    bool isPalindrome(int x) {
        int arr[64];
        //memset(arr, -1,sizeof(arr)/sizeof(int));
        int xx = x, i = 0;
        
        if (xx < 0)
            return 0;
        else if (xx < 10)
            return 1;

        //创建数字数组
        while (xx != 0) {
            int num_end = xx % 10;
            arr[i] = num_end;
            xx /= 10;
            //cout << arr[i] << endl;
            ++i;
        }
        
        int l = 0, r = 0;
        //偶数回文
        if (i % 2 == 0) {
            //cout << "偶数回文" << endl;
            l = i / 2 - 1; r = i / 2;
            while(r < i || l > 0) {
                if (arr[l] != arr[r])
                    break;
                ++r; --l;
            }
        }
        //奇数回文
        else {
            //cout << "奇数回文" << endl;
            r = l = i / 2;
            while (r < i || l > 0) {
                if (arr[l] != arr[r])
                    break;
                ++r; --l;
            }
        }
        if (l < 0)
            return 1;
        else
            return 0;
    }
};
```



方法二：算数法

```c++
//方法二：
/*
思想：将数字通过计算分为两半；例如：12211分成12和11；2242分成22和24
然后比较这两个数字之模是否为1
*/
class Solution {
public:
    bool isPalindrome(int x) {
        // 特殊情况：
        // 如上所述，当 x < 0 时，x 不是回文数。
        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，
        // 则其第一位数字也应该是 0
        // 只有 0 满足这一属性
        if (x < 0 || (x % 10 == 0 && x != 0)) {
            return false;
        }

        int revertedNumber = 0;
        while (x > revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }
        //通过算数原理有效避免了回文奇偶的繁杂判断
        return x == revertedNumber || x == revertedNumber / 10;
    }
};
```





# 10、正则表达式













# 11、成最多水的容器

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

 

**示例 1：**

![img](D:\Users\suyu\Pictures\Typora-picture\question_11.jpg)

```cpp
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```cpp
输入：height = [1,1]
输出：1
```

 

**提示：**

- `n == height.length`
- `2 <= n <= 105`
- `0 <= height[i] <= 104`



方法一：双指针法

```cpp
#include <iostream>
#include <vector>
#include <math.h>

using namespace std;
// 11.盛水最多的容器

class Solution
{
public:
    int maxArea(vector<int> &height)
    {
        // i为左边的板子j为右边的板子
        // S(盛水量)=min(h[i],h[j])*(j-i)
        int volume = 0;
        int i = 0, j = height.size() - 1;
        while (i < j)
        {
            //注意：不同编译器对于heigh[i++]的处理方式不同
            if (height[i] < height[j]) {
                volume = max(volume, (j - i) * height[i]);
                i++;
            }
            else {
                volume = max(volume, (j - i) * height[j]);
                j--;
            }
        }
        return volume;
    }
};

int main()
{
    Solution max;
    vector<int> arr = {1, 2, 1};
    cout << max.maxArea(arr);
    return 0;
}
```







# 12、整数转罗马数字



罗马数字包含以下七种字符： `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```c++
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做 `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给你一个整数，将其转为罗马数字。

 

**示例 1:**

```c++
输入: num = 3
输出: "III"
```

**示例 2:**

```c++
输入: num = 4
输出: "IV"
```

**示例 3:**

```c++
输入: num = 9
输出: "IX"
```

**示例 4:**

```c++
输入: num = 58
输出: "LVIII"
解释: L = 50, V = 5, III = 3.
```

**示例 5:**

```c++
输入: num = 1994
输出: "MCMXCIV"
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

 

**提示：**

- `1 <= num <= 3999`



```c++
#include<iostream>
#include<vector>

using namespace std;

//12、整数转罗马数字

//创建 数字——罗马表（注意取核心数字）
const pair<int, string> value_roman[] = {
    {1000, "M"},
    {900,  "CM"},
    {500,  "D"},
    {400,  "CD"},
    {100,  "C"},
    {90,   "XC"},
    {50,   "L"},
    {40,   "XL"},
    {10,   "X"},
    {9,    "IX"},
    {5,    "V"},
    {4,    "IV"},
    {1,    "I"},
};

/*
例如：142-> CXLII，130->CXXX
可得：从高位到低位，取最大合理的罗马数字

*/
class Solution {
public:
    string intToRoman(int num) {
        string ans ="";
        //类似于python中for in range（）
        for (const auto& [value, roman] : value_roman) {
            //cout << value << " " << roman << endl;
            //如果num的值大于value的值，就可以不分罗马化数字
            while (num >= value) {
                num -= value;
                ans += roman;
            }
            if (num == 0)
                break;
        }
        return ans;
    }
};

int main() {
    Solution roman;
    string ans =roman.intToRoman(12);
    cout << ans;
	return 0;
}
```







# 13、罗马数字转整数

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

```cpp
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。`12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做 `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。

 

**示例 1:**

```cpp
输入: s = "III"
输出: 3
```

**示例 2:**

```cpp
输入: s = "IV"
输出: 4
```

**示例 3:**

```cpp
输入: s = "IX"
输出: 9
```

**示例 4:**

```cpp
输入: s = "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
```

**示例 5:**

```cpp
输入: s = "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

 

**提示：**

- `1 <= s.length <= 15`
- `s` 仅含字符 `('I', 'V', 'X', 'L', 'C', 'D', 'M')`
- 题目数据保证 `s` 是一个有效的罗马数字，且表示整数在范围 `[1, 3999]` 内
- 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
- IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
- 关于罗马数字的详尽书写规则，可以参考 [罗马数字 - Mathematics ](https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/罗马数字#knowledge_article)。



```cpp
#include<iostream>
#include<vector>

using namespace std;

//13、罗马数字转整数

//创建 数字——罗马表（注意取核心数字）
const pair<int, char> value_roman[] = {
    {1,    'I'},
    {5,    'V'},
    {10,   'X'},
    {50,   'L'},
    {100,  'C'},
    {500,  'D'},
    {1000, 'M'},
};

class Solution {
public:
    /*
    输入: s = "MCMXCIV"
    输出: 1994
    解释: M = 1000, CM = 900, XC = 90, IV = 4
    
    输入: s = "VIII"
    输出: 8
    */
    
    int romanToInt(string s) {
        int ans = 0;
        for (int i = s.size()-1; i >= 0; --i) {
            //s.at(i);
            for (const auto& [value, roman] : value_roman) {
                //注意这儿的判断顺序，
                //1、罗马数字相等时，ans小于对应罗马值
                if (s[i] == roman && ans <= value) {
                    ans += value;
                    break;
                }//2、罗马数字相等时，为连续2个一样的罗马数字
                else if (s[i] == roman && s[i] == s[i + 1]) {
                    ans += value;
                    break;
                }//3、罗马数字相等时，ans大于对应罗马值（IIV这种就得减去II）
                else if (s[i] == roman && ans > value) {
                    ans -= value;
                    break;
                }
            }
        }
        return ans;
    }
};

int main() {              

    Solution ro;
    cout<<ro.romanToInt("DCXXI");
	return 0;
}
```







# 14、最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

 

**示例 1：**

```cpp
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**示例 2：**

```cpp
输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```

 

**提示：**

- `1 <= strs.length <= 200`
- `0 <= strs[i].length <= 200`
- `strs[i]` 仅由小写英文字母组成



```cpp
#include<iostream>
#include<vector>
#include<string>
//#include<minmax.h>
#include<algorithm>

using namespace std;

template<typename T>
T my_min(T a, T b) {
    if (a >= b)
        return b;
    else
        return a;
}

//14、最长公共前缀
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        string ans;
        size_t min_len = 999999;
        int count = 0, flag = 0;
        int strs_len = strs.size();
        for (int i = 0; i < strs_len; ++i) {
            min_len = my_min(min_len, strs[i].size());
        }

        for (int i = 0; i < min_len; i++) {
            count = 0;
            for (int j = 1; j < strs_len; j++) {
                if (strs[j][i] == strs[0][i]) {
                    ++count;
                }
                else
                    flag = 1;
            }
            if (flag == 1)
                break;
            if (count == strs_len - 1)
                ans += strs[0][i];
        }
        return ans;
    }
};

int main() {
    Solution qstr;
    vector<string> strs = { "cir","car" };
    cout<<qstr.longestCommonPrefix(strs);
	return 0;
}
```







# 15、三数之和

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。



**示例 1：**

```cpp
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```cpp
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```cpp
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

 

**提示：**

- `3 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`

思路：

**算法流程:**
1、特判，对于数组长度n,如果数组为null或者数组长度小于3
返回空。
2、对数组进行排序。
3、遍历排序后数组:
		●若nums[ij> 0:因为已经排序好,所以后面不可能有三个数加和等于0，直接返		回结果。
		●对于重复元素:跳过,避免出现重复解
		●令左指针L=i+1,右指针R=n-1,当L<R时,执行循环:
				●当nums[i] + nums[[] + mums[R]==0,执行循环，
				判断左界和右界是否和下一-位置重复，去除重复解。
				并同时将L,R移到下- -位置，寻找新的解
				●若和大于0,说明nums[R]太大，R左移
				●若和小于0,说明nums[]太小，L右移

**复杂度分析**
●时间复杂度: 0 (n2), 数组排序O(NlogN),遍历数组O(n)，双指针遍历O(n), 总体O(NlogN) + O(n) * O(n), 	O (n²)
●空间复杂度: O(1)



```cpp

#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>>ans;
        //ans.resize(100);
        size_t len = nums.size();
        
        //当数组长度小于1，就反回空
        if (len <= 0)
            return ans;
        
        //从小到大排序
        sort(nums.begin(),nums.end());
        
        //如果最小的数都大于0则，不可能有满足条件的三元组
        if (nums[0] > 0)
            return ans;

        for (int i = 0; i < len; ++i) {
            //跳过重复的元素
            if (i > 0 && nums[i] == nums[i - 1])
                continue;

            int left = i + 1, right = len - 1;
            while (left < right) {
                if (nums[i] + nums[left] + nums[right] == 0) {
                    ans.push_back({ nums[i] , nums[left] , nums[right] });

                    //左指针和右指针分别跳过重复的元素，并分别加一寻求新解
                    while (left < right && nums[left] == nums[left + 1])
                        left += 1;
                    while (left < right && nums[right] == nums[right - 1])
                        right -= 1;

                    ++left;
                    --right;
                }
                //如果三元组和大于0在则将右指针左移，减小和
                else if (nums[i] + nums[left] + nums[right] > 0)
                    right -= 1;
                else
                    left += 1;
            }
        }
        return ans;
    }
};

int main() {
    
	return 0;
}
```







# 16、最接近的三个数之和

给你一个长度为 `n` 的整数数组 `nums` 和 一个目标值 `target`。请你从 `nums` 中选出三个整数，使它们的和与 `target` 最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。

 

**示例 1：**

```cpp
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```

**示例 2：**

```cpp
输入：nums = [0,0,0], target = 1
输出：0
```

 

**提示：**

- `3 <= nums.length <= 1000`
- `-1000 <= nums[i] <= 1000`
- `-104 <= target <= 104`



```cpp

#include<algorithm>
#include<iostream>
#include<vector>

using namespace std;

//nums = [-1,2,1,-4], target = 1
//           pa   pb
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        int len = nums.size();
        //ans的初始值是分重要
        int ans = nums[0] + nums[1] + nums[2];

        //由小到大
        sort(nums.begin(), nums.end());

        for (int i = 0; i < len; ++i) {
            
            /*if (i > 0 && nums[i] == nums[i - 1])
                continue;*/

            int pa = i + 1;
            int pb = len - 1;

            //-4,-1,1,2
            while (pa < pb) {

                int sum = nums[pa] + nums[pb] + nums[i];
                if (abs(sum - target) < abs(ans - target))
                    ans = sum;

                if (sum > target)
                    --pb;
                else if (sum < target)
                    ++pa;
                else
                    return sum;
            }
        }
        return ans;
    }
};

int main() {

    Solution test;
    vector<int>num = {-13,592,-501,770,-952,-675,322,-829,-246,657,608,485,-112,967,-30,182,-969,559,-286,-64,24,365,-158,701,535,-429,-217,28,948,-114,-536,-711,693,23,-958,-283,-700,-672,311,314,-712,-594,-351,658,747,949,70,888,166,495,244,-380,-654,454,-281,-811,-168,-839,-106,877,-216,523,-234,-8,289,-175,920,-237,-791,-976,-509,-4,-3,298,-190,194,-328,265,150,210,285,-176,-646,-465,-97,-107,668,892,612,-54,-272,-910,557,-212,-930,-198,38,-365,-729,-410,932,4,-565,-329,-456,224,443,-529,-428,-294,191,229,112,-867,-163,-979,236,-227,-388,-209,984,188,-549,970,951,-119,-146,801,-554,564,-769,334,-819,-356,-724,-219,527,-405,-27,-759,722,-774,758,394,146,517,870,-208,742,-782,336,-364,-558,-417,663,-914,536,293,-818,847,-322,408,876,-823,827,167};
    int target = 7175;
    cout<<test.threeSumClosest(num, target);
	return 0;
}
```









# 17、电话号码的字母组合

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](D:\Users\suyu\Pictures\Typora-picture\200px-telephone-keypad2svg.png)

 

**示例 1：**

```cpp
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**示例 2：**

```cpp
输入：digits = ""
输出：[]
```

**示例 3：**

```cpp
输入：digits = "2"
输出：["a","b","c"]
```

 

**提示：**

- `0 <= digits.length <= 4`
- `digits[i]` 是范围 `['2', '9']` 的一个数字。



思路：通过电话号码和对应的字母构造树再通过DFS求解

```cpp

#include<iostream>
#include<map>
#include<vector>
#include<string>

using namespace std;

class Solution {
private:
    map<int, string>num_world = {
            {'2',"abc"},{'3',"def"},
            {'4',"ghi"},{'5',"jkl"},
            {'6',"mno"},{'7',"pqrs"},
            {'8',"tuv"},{'9',"wxyz"}
    };
    vector<string>ans;
    string current;
    //"234"
    void numWorldDfs(int index,string Digits) {
        //出口
        if (index == Digits.size()) {
            ans.push_back(current);
            return;
        }
        //通过哈希获取每层digital的号码对应的字母组合
        string str0 = num_world[Digits[index]];
        for (int i = 0; i < str0.size(); ++i) {
            current.push_back(str0[i]);     //临时压入
            numWorldDfs(index + 1, Digits);     //层数加一，dfs深搜
            current.pop_back();     //回溯状态
        }
    }

public:
    vector<string> letterCombinations(string digits) {
        if (digits.size() == 0) {
            return ans;
        }
        else {
            numWorldDfs(0, digits);
            return ans;
        }
    }
};

int main() {
    Solution test;
    test.letterCombinations("234");
	return 0;
}
```



优化：

```cpp
class Solution {
private:
    char map[10][10] = { "", "",
    "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };

    vector<string> res;
    char path[10];

    void dfs(int u, int n, string digits){
        if (u == n){ // 如果搜索到n个字符组成的单词，则收集结果        
            res.push_back(string(path));
            return;
        }

        int t = digits[u] - '0'; // 获取第u个的数字
        char chs[5]; // chs存储当前数字对应的字符集
        memcpy(chs, map[t], strlen(map[t]));

        for (int i = 0; i < strlen(map[t]); i++){
            path[u] = chs[i];
            dfs(u + 1, n, digits);
            // path数组会自动恢复
        }
    }
    
public:
    vector<string> letterCombinations(string digits) {
        if (digits.size() == 0) return {};
        dfs(0, digits.size(), digits);
        return res;
    }
};
```









# 18、四数之和

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 **任意顺序** 返回答案 。

 

**示例 1：**

```cpp
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**示例 2：**

```cpp
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```

 

**提示：**

- `1 <= nums.length <= 200`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`



双指针法：

```cpp

#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>>ans;
        int len = nums.size();
        if (len < 4)
            return ans;
        
        // 1,-2,1,5,3,8,-6
        // i  j l        r  初状态
        //        i j l  r  末状态
        sort(nums.begin(), nums.end());
        for (int i = 0; i < len - 3; ++i) {
            //去重
            if (i > 0 && nums[i] == nums[i - 1])
                continue;
            for (int j = i + 1; j < len - 2; ++j) {
                //去重
                if (j > i + 1 && nums[j] == nums[j - 1])
                    continue;
                int left = j + 1, right = len - 1;
                
                while (left < right) {
                    //启用long long防止数据溢出
                    long long sum = (long long)nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum == target) {
                        ans.push_back({ nums[i],nums[j],nums[left],nums[right] });
                        //去除重复的没有发生变化的数值
                        while (left < right && nums[left] == nums[left + 1])
                            ++left;
                        while (left < right && nums[right] == nums[right - 1])
                            --right;
                        //移动双指针找到未重复值
                        ++left, --right;
                    }
                    //移动双指针
                    else if (sum > target)
                        --right;
                    else
                        ++left;
                }
            }
        }
        return ans;
    }
};

int main() {
    Solution test;
    //-2,-1,0,0,1,2
    vector<int>arrat = { 1,0,-1,0,-2,2 };
    int target = 0;
    test.fourSum(arrat, target);
	return 0;
}
```









# 19、删除链表的倒数第n个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

 

**示例 1：**

![img](D:\Users\suyu\Pictures\Typora-picture\remove_ex1.jpg)

```cpp
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**示例 2：**

```cpp
输入：head = [1], n = 1
输出：[]
```

**示例 3：**

```cpp
输入：head = [1,2], n = 1
输出：[1]
```

 

**提示：**

- 链表中结点的数目为 `sz`
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`



```cpp
#include<iostream>

using namespace std;

struct ListNode {
	int val;
	ListNode* next;
	ListNode() : val(0), next(nullptr) {}
	ListNode(int x) : val(x), next(nullptr) {}
	ListNode(int x, ListNode* next) : val(x), next(next) {}
};
 

class Solution {
public:
	int getLength(ListNode* head) {
		int length = 0;
		while (head) {
			++length;
			head = head->next;
		}
		return length;
	}

public:
	ListNode* removeNthFromEnd(ListNode* head, int n) {
		ListNode* p1 = new ListNode(0, head);
		int len = getLength(head);
		ListNode* p2 = p1;
		//len-n为我们要删除的结点的前一个结点
		for (int i = 1; i <= len - n; ++i) {
			p2 = p2->next;
		}
		p2->next = p2->next->next;  // Now this is safe  
		ListNode* ans = p1->next;
		delete p1;
		return ans;
	}
};


int main() {

	/*ListNode* ptr = new ListNode(0);
	ListNode* head = ptr;
	for (int i = 1; i <= 5; ++i) {
		ListNode* node = new ListNode(i);
		ptr->next = node;
		ptr = ptr->next;
	}*/

	ListNode* head = new ListNode(1);
	Solution text;
	text.removeNthFromEnd(head, 1);
	/*cout << text.getLength(head->next)<< endl;
	text.removeNthFromEnd(head->next,2);*/

	return 0;
}
```









# 20、有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

 

**示例 1：**

```cpp
输入：s = "()"
输出：true
```

**示例 2：**

```cpp
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```cpp
输入：s = "(]"
输出：false
```

 

**提示：**

- `1 <= s.length <= 104`
- `s` 仅由括号 `'()[]{}'` 组成



```cpp

#include<iostream>
#include<stack>
#include<unordered_map>
#include<algorithm>

using namespace std;

//一开始把题意想错了，做半天做不出来(╥╯^╰╥)
//class Solution {
//private:
//    //声明括号集
//    pair<char, char>brackets[3] = {
//        {'(',')'},{'[',']'},{'{','}'} };
//
//public:
//    bool seeBrakets(char ch1, char ch2) {
//        for (int j = 0; j < 3; ++j) {
//            if (ch1 == brackets[j].first && ch2 == brackets[j].second)
//                return true;
//            if (ch2 == brackets[j].first && ch1 == brackets[j].second)
//                return true;
//        }
//        return false;
//    }
//    // "{ [ ( ) [ ] ] }"
//    bool isValid(string s) {
//        stack<char> strStack;
//        int len = s.size();
//        int i = 0;
//
//        if (len % 2 != 0)
//            return false;
//
//        strStack.push(s[0]);
//        for (int i = 1; i < len; ++i) {
//            if (seeBrakets(strStack.top(), s[i])) {
//                strStack.pop();
//                continue;
//            }
//            strStack.push(s[i]);
//        }
//        if (strStack.empty())
//            return true;
//        else
//            return false;
//    }
//};

class Solution {
public:
    bool isValid(string s) {
        int n = s.size();
        if (n % 2 == 1) {
            return false;
        }

        unordered_map<char, char> pairs = {
            {')', '('},
            {']', '['},
            {'}', '{'}
        };
        stack<char> stk;
        for (char ch : s) {
            if (pairs.count(ch)) {
                if (stk.empty() || stk.top() != pairs[ch]) {
                    return false;
                }
                stk.pop();
            }
            else {
                stk.push(ch);
            }
        }
        return stk.empty();
    }
};

int main() {

    Solution test;
    cout<<test.isValid("[[[[");
    //for
	return 0;
}
```







# 21、合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

**示例 1：**

![img](D:\Users\suyu\Pictures\Typora-picture\merge_ex1.jpg)

```cpp
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```cpp
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```cpp
输入：l1 = [], l2 = [0]
输出：[0]
```

 

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列



```cpp

#include<iostream>
#include<string>

using namespace std;

//Definition for singly-linked list.
    struct ListNode {
        int val;
        ListNode *next;
        ListNode() : val(0), next(nullptr) {}
        ListNode(int x) : val(x), next(nullptr) {}
        ListNode(int x, ListNode *next) : val(x), next(next) {}
 };
 
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if (list1 == nullptr && list2 != nullptr)
            return list2;
        else if (list1 != nullptr && list2 == nullptr)
            return list1;
        else if(list1 == nullptr && list2 == nullptr)
            return nullptr;

        ListNode* l1 = list1;
        ListNode* l2 = list2;
        ListNode* head = new ListNode();
        ListNode* cur = head;
        // 1->5->6
        // 2->4->5->7
        //1 2 3 4 5
        //1 2 3
        //快慢双指针(断尾接上头指针)
        while (l1 != nullptr && l2 != nullptr) {
            if (l1->val < l2->val) {
                cur->next = l1;
                l1 = l1->next;
            }
            else {
                cur->next = l2;
                l2 = l2->next;
            }
            cur = cur->next;
        }
        if (l1 != nullptr)
            cur->next = l1;
        else
            cur->next = l2;

        return head->next;
    }
};

int main() {

	ListNode* ptr1 = new ListNode(0);
	ListNode* head1 = ptr1;
	for (int i = 1; i <= 5; ++i) {
		ListNode* node = new ListNode(i);
		ptr1->next = node;
		ptr1 = ptr1->next;
	}

    ListNode* ptr2 = new ListNode(0);
    ListNode* head2 = ptr2;
    for (int i = 1; i <= 3; ++i) {
        ListNode* node = new ListNode(i);
        ptr2->next = node;
        ptr2 = ptr2->next;
    }

	//ListNode* head = new ListNode(1);
	Solution text;
	text.mergeTwoLists(head1->next,head2->next);
	/*cout << text.getLength(head->next)<< endl;
	text.removeNthFromEnd(head->next,2);*/


	return 0;
}
```







# 22、括号生成

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

 

**示例 1：**

```cpp
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```cpp
输入：n = 1
输出：["()"]
```

 

**提示：**

- `1 <= n <= 8`



递归回溯法：

```cpp

#include<iostream>
#include<string>
#include<vector>

using namespace std;

class Solution {
private:
    vector<string> ans;
    string str;
    void dfs(int n, int lift, int right)
    {
        if (str.length() == 2 * n){
            ans.emplace_back(str);
            return;
        }

        if (lift < n){  //可以填左括号
            str.push_back('(');
            dfs(n, lift + 1, right);
            str.pop_back();
        }
        if (right < lift){  //可以填右括号
            str.push_back(')');
            dfs(n, lift, right + 1);
            str.pop_back();
        }
    }
public:
    vector<string> generateParenthesis(int n) {
        dfs(n, 0, 0);
        return ans;
    }
};


int main() {
	Solution test;
	test.generateParenthesis(3);

	return 0;
}
```











# 23、合并K个升序链表

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

 

**示例 1：**

```cpp
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**

```cpp
输入：lists = []
输出：[]
```

**示例 3：**

```cpp
输入：lists = [[]]
输出：[]
```

 

**提示：**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按 **升序** 排列
- `lists[i].length` 的总和不超过 `10^4`



方法一：优先队列（也是我自己想出来的方法）

```cpp
#include<iostream>
#include<queue>
#include<vector>
#include<algorithm>

using namespace std;

//Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode* next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

 
class Solution {
private:
    struct cmp{
        bool operator()(ListNode* a, ListNode* b) {
            return a->val > b->val;
        }
    };
    //堆排序队列（优先队列）
    priority_queue<ListNode*, vector<ListNode*>, cmp>que;

public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        //获取每个链表的最顶层结点
        for (const auto& node : lists) {
            if (node != nullptr)
                que.push(node);
        }
        ListNode* head = new ListNode();
        ListNode* ptr = head;
        //如果que队列不为空
        while (!que.empty()) {
            //将que队列中最小的结点接入头结点
            ListNode* node = que.top();
            que.pop();
            ptr->next = node;
            ptr = ptr->next;
            //如果接入头结点的那个链表还有结点，就将结点前置放入que队列
            if (node->next != nullptr)
                que.push(node->next);
        }
        return head->next;
    }
};

int main() {

	return 0;
}
```







# 24、两两交换链表节点

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

 

**示例 1：**

![img](D:\Users\suyu\Pictures\Typora-picture\swap_ex1.jpg)

```cpp
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```cpp
输入：head = []
输出：[]
```

**示例 3：**

```cpp
输入：head = [1]
输出：[1]
```

 

**提示：**

- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`

<img src="D:\Users\suyu\Pictures\Typora-picture\image-20231028124321211.png" alt="image-20231028124321211" style="zoom: 60%;" />

<img src="D:\Users\suyu\Pictures\Typora-picture\image-20231028124339120.png" alt="image-20231028124339120" style="zoom:50%;" />

<img src="D:\Users\suyu\Pictures\Typora-picture\image-20231028125345727.png" alt="image-20231028125345727" style="zoom:50%;" />

<img src="D:\Users\suyu\Pictures\Typora-picture\image-20231028125405270.png" alt="image-20231028125405270" style="zoom:50%;" />



迭代法：

```cpp

#include<iostream>
#include<string>
#include<algorithm>
using namespace std;


//Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode* next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode* next) : val(x), next(next) {}
};
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        //建立哨兵结点解决奇偶麻烦
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* temp = dummyHead;

        while (temp->next != nullptr && temp->next->next != nullptr) {
            //以temp指针为参考点交换后面的两个节点
            //以temp为基础更行节点
            ListNode* node1 = temp->next;
            ListNode* node2 = temp->next->next;
            temp->next = node2;
            node1->next = node2->next;
            node2->next = node1;
            temp = node1;
        }
        ListNode* ans = dummyHead->next;
        delete dummyHead;
        return ans;
    }
};

int main() {
    ListNode* ptr1 = new ListNode(0);
	ListNode* head1 = ptr1;
	for (int i = 1; i < 6; ++i) {
		ListNode* node = new ListNode(i);
		ptr1->next = node;
		ptr1 = ptr1->next;
	}

    Solution text;
    text.swapPairs(head1->next);
    return 0;
}
```







# 25、K个一组翻转链表

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

 

**示例 1：**

![img](D:\Users\suyu\Pictures\Typora-picture\reverse_ex1.jpg)

```cpp
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

**示例 2：**

![img](D:\Users\suyu\Pictures\Typora-picture\reverse_ex2.jpg)

```cpp
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```

 

**提示：**

- 链表中的节点数目为 `n`
- `1 <= k <= n <= 5000`
- `0 <= Node.val <= 1000`

 

**进阶：**你可以设计一个只用 `O(1)` 额外内存空间的算法解决此问题吗？



```cpp
#include<iostream>
#include<algorithm>

using namespace std;


//Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};


class Solution {
private:
    pair<ListNode*,ListNode*>overturnPtr(ListNode* head, ListNode* watchPtr) {
        ListNode* prev = watchPtr->next;
        ListNode* reHead = head;
        while (prev != watchPtr) {
            ListNode* nex = reHead->next;
            reHead->next = prev;
            prev = reHead;
            reHead = nex;
        }
        return make_pair(watchPtr, head);
    }

public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        //创建头结点
        ListNode* nullHead = new ListNode();
        nullHead->next = head;
        ListNode* pre = nullHead;

        while (head != nullptr) {
            //移动检查是否还有K个结点
            ListNode* watchPtr = pre;
            //通过移动watchPtr去检查链表是否还有足够的结点需要翻转
            for (int i = 0; i < k; ++i) {
                watchPtr = watchPtr->next;
                //如果watchPtr为空节点则翻转完毕
                if (watchPtr == nullptr)
                    return nullHead->next;
            }
            
            //获取尾节点
            ListNode* tail = watchPtr->next;
            //开始翻转
            pair<ListNode*, ListNode*>tie = overturnPtr(head, watchPtr);
            //接入总链表
            pre->next = tie.first;
            
            //还原watchPtr和head的位置
            watchPtr = head;
            //head = tail;
            //移动pre和head的位置
            pre = watchPtr;
            head = tail;
        }
        return nullHead->next;
    }
};

//优化：
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* cur = head;
        int n = 0;
        //遍历链表
        while (cur) {
            cur = cur->next;
            n++;
        }
        n /= k;     //n=n/k，获取有多少个重复翻转的子链表
        ListNode* pHead = new ListNode(0);
        ListNode* prev = pHead;
        cur = head;
        // 需要重复的组数
        for (int i = 0; i < n; i++) {
            ListNode* tmp = cur;
            for (int j = 0; j < k; j++) {
                ListNode* newcur = cur->next;
                cur->next = prev->next;
                prev->next = cur;
                cur = newcur;
            }
            prev = tmp;
        }
        prev->next = cur;
        cur = pHead->next;
        delete pHead;
        return cur;
    }
};

int main() {

	return 0;
}
```







# 26、删除有序数组中的重复项

给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k` 。

**判题标准:**

系统会用下面的代码来测试你的题解:

```cpp
int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有断言都通过，那么您的题解将被 **通过**。

 

**示例 1：**

```cpp
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```cpp
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

 

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-104 <= nums[i] <= 104`
- `nums` 已按 **非严格递增** 排列



```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#include<set>
using namespace std;

//通过快慢指针来解答
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int len = nums.size();
        int slow = 0;
        for (int fast = 0; fast < len; ++fast) {
            if (nums[fast] != nums[slow])
                nums[++slow]=nums[fast];
        }
        return slow+1;
    }
};

int main() {
    vector<int>nums = { 0,1,1,1,2,2,3,3,4 };
    Solution test;
    test.removeDuplicates(nums);
	return 0;
}
```









# 27、移除元素

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

 

**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```cpp
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

 

**示例 1：**

```cpp
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

**示例 2：**

```cpp
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```

 

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`



```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#include<set>
using namespace std;

//通过快慢指针来解答
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int len = nums.size();
        int slow = len - 1;
        for (int fast = 0; fast < len && fast <= slow; ++fast) {
            if (nums[fast] == val) {
                swap(nums[fast], nums[slow]);
                //回退fast巧妙的防止了nums[slow]和val相同的无效交换
                --fast, --slow; 
            }
        }
        return slow + 1;
    }
};

//方法二：
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int i, j;
        int Len = nums.size();
        if (Len == 0) return 0;
        for (j = 0, i = 0; i < Len; i++) {
            if (nums[i] != val) {
                nums[j] = nums[i];
                j++;
            }
        }
        return j;
    }
};

int main() {
    vector<int>nums = { 2 };
    Solution test;
    test.removeElement(nums,2);
    return 0;
}
```









# 28、找出字符串中第一个匹配项的下标

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

 

**示例 1：**

```cpp
输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。
```

**示例 2：**

```cpp
输入：haystack = "leetcode", needle = "leeto"
输出：-1
解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 。
```

 

**提示：**

- `1 <= haystack.length, needle.length <= 104`
- `haystack` 和 `needle` 仅由小写英文字符组成



```cpp

#include<iostream>
#include<vector>
#include<array>
#include<string>
#include<algorithm>
using namespace std;

class Solution {
public:
    void getNext(vector<int> &next, const string& s) {
        int j = 0, k = -1;
        //记录第i个字符前的字符串的最长相等前后缀的长度
        next[0] = -1;//第一个字符前无字符串，给值-1
        
        while (j < s.size()) {
            //k为-1 或 比较的字符相等时
            if (k == -1 || s[j] == s[k]) {
                k++; j++;
                next[j] = k;
            }
            else {
                k = next[k];
            }
        }
    }
// 0 1 2 3 4 5 6 7
// a b c a b c m n
//-1 0 0 0 1 2 3 0
public:
    int strStr(string haystack, string needle) {
        int n_len = needle.size();
        int h_len = haystack.size();
        int i = 0, j = 0;
        vector<int>next(n_len + 1, 0);
        if (n_len == 0)
            return -1;
        getNext(next, needle);

        while (i < h_len && j < n_len) {
            if (j == -1 || haystack[i] == needle[j]) {
                i++; j++;
            }
            else
                j = next[j];
        }
        if (j >= n_len)
            return(i - n_len);
        else
            return -1;
    }
};

int main() {
    Solution test;
    string str = "abcabcmn";
    vector<int>next(str.size() + 1, 0);
    test.getNext(next, str);

    for (int i = 0; i < str.size(); ++i) {
        cout << next[i]<<' ';
    }
	return 0;
}
```



**看得懂，原理也懂，但是自己写不出来	(╥╯^╰╥)**







# 29、两数相除

给你两个整数，被除数 `dividend` 和除数 `divisor`。将两数相除，要求 **不使用** 乘法、除法和取余运算。

整数除法应该向零截断，也就是截去（`truncate`）其小数部分。例如，`8.345` 将被截断为 `8` ，`-2.7335` 将被截断至 `-2` 。

返回被除数 `dividend` 除以除数 `divisor` 得到的 **商** 。

**注意：**假设我们的环境只能存储 **32 位** 有符号整数，其数值范围是 `[−231, 231 − 1]` 。本题中，如果商 **严格大于** `231 − 1` ，则返回 `231 − 1` ；如果商 **严格小于** `-231` ，则返回 `-231` 。

 

**示例 1:**

```cpp
输入: dividend = 10, divisor = 3
输出: 3
解释: 10/3 = 3.33333.. ，向零截断后得到 3 。
```

**示例 2:**

```cpp
输入: dividend = 7, divisor = -3
输出: -2
解释: 7/-3 = -2.33333.. ，向零截断后得到 -2 。
```

 

**提示：**

- `-231 <= dividend, divisor <= 231 - 1`
- `divisor != 0`



```cpp

#include<iostream>
#include<vector>
#include<bitset>
#include<algorithm>
using namespace std;

//1~10:
// 4/5=0; 6/4=1

class Solution {
public:
    int divide(int dividend, int divisor) {

        int res = 0;
        int sign = 1;
        if (dividend == INT_MIN && divisor == -1)
            return INT_MAX;
        //可选2：
        if (dividend == INT_MIN && divisor == 1)
            return INT_MIN;

        // 处理边界，防止转正数溢出
        // 除数绝对值最大，结果必为 0 或 1
        if (divisor == INT_MIN) {
            return dividend == divisor ? 1 : 0;
        }

        // 被除数先减去一个除数
        if (dividend == INT_MIN) {
            dividend -= -abs(divisor);
            res += 1;
        }

        if (dividend > 0 && divisor > 0|| dividend < 0 && divisor < 0)
            sign = 1;
        if (dividend > 0 && divisor < 0 || dividend < 0 && divisor > 0)
            sign = -1;

        int ua = abs(dividend);
        int ub = abs(divisor);
        for (int i = 31; i >= 0; i--) {
			/*每次将ua向右移动i位去和ub比较大小，
			  如果大于ub代表最大可以大2^i倍*/
            if ((ua >> i) >= ub) {
                ua = ua - (ub << i);
                //可选1：
                // 代码优化：这里控制 ans 大于等于 INT_MAX
                /*if (res > INT_MAX - (1 << i)) {
                    return INT_MIN;
                }*/
                res += 1 << i;
            }
        }
        // bug 修复：因为不能使用乘号，所以将乘号换成三目运算符
        return sign == 1 ? res : -res;
    }
};

int main() {
    Solution test;
               //dicide(INT_MIN,    -1)
    cout << test.divide(-2147483648,1) << endl;
	return 0;
}
```







# 30、串联所有单词的子串

给定一个字符串 `s` 和一个字符串数组 `words`**。** `words` 中所有字符串 **长度相同**。

 `s` 中的 **串联子串** 是指一个包含 `words` 中所有字符串以任意顺序排列连接起来的子串。

- 例如，如果 `words = ["ab","cd","ef"]`， 那么 `"abcdef"`， `"abefcd"`，`"cdabef"`， `"cdefab"`，`"efabcd"`， 和 `"efcdab"` 都是串联子串。 `"acdbef"` 不是串联子串，因为他不是任何 `words` 排列的连接。

返回所有串联子串在 `s` 中的开始索引。你可以以 **任意顺序** 返回答案。

 

**示例 1：**

```cpp
输入：s = "barfoothefoobarman", words = ["foo","bar"]
输出：[0,9]
解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。
子串 "barfoo" 开始位置是 0。它是 words 中以 ["bar","foo"] 顺序排列的连接。
子串 "foobar" 开始位置是 9。它是 words 中以 ["foo","bar"] 顺序排列的连接。
输出顺序无关紧要。返回 [9,0] 也是可以的。
```

**示例 2：**

```cpp
输入：s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]
输出：[]
解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。
s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。
所以我们返回一个空数组。
```

**示例 3：**

```cpp
输入：s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]
输出：[6,9,12]
解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。
子串 "foobarthe" 开始位置是 6。它是 words 中以 ["foo","bar","the"] 顺序排列的连接。
子串 "barthefoo" 开始位置是 9。它是 words 中以 ["bar","the","foo"] 顺序排列的连接。
子串 "thefoobar" 开始位置是 12。它是 words 中以 ["the","foo","bar"] 顺序排列的连接。
```

 

**提示：**

- `1 <= s.length <= 104`
- `1 <= words.length <= 5000`
- `1 <= words[i].length <= 30`
- `words[i]` 和 `s` 由小写英文字母组成





```cpp
class Solution {
public:
    vector<int> findSubstring(string &s, vector<string> &words) {
        vector<int> res;
        int m = words.size(), n = words[0].size(), ls = s.size();
        for (int i = 0; i < n && i + m * n <= ls; ++i) {
            unordered_map<string, int> differ;
            for (int j = 0; j < m; ++j) {
                ++differ[s.substr(i + j * n, n)];
            }
            for (string &word: words) {
                if (--differ[word] == 0) {
                    differ.erase(word);
                }
            }
            for (int start = i; start < ls - m * n + 1; start += n) {
                if (start != i) {
                    string word = s.substr(start + (m - 1) * n, n);
                    if (++differ[word] == 0) {
                        differ.erase(word);
                    }
                    word = s.substr(start - n, n);
                    if (--differ[word] == 0) {
                        differ.erase(word);
                    }
                }
                if (differ.empty()) {
                    res.emplace_back(start);
                }
            }
        }
        return res;
    }
};
```



我的解答，但是有奇怪的bug

```cpp
#include<iostream>
#include<algorithm>
#include<unordered_map>
#include<vector>
#include<bitset>
using namespace std;

class Solution {
public:
	vector<int> findSubstring(string s, vector<string>& words) {
		int len = words.size();
		int wordLen = words[0].size();
		string str;
		unordered_map<char, int>word;
		vector<int>ans;
		//数据预处理
		for (int i = 0; i < s.size(); i += wordLen)
			str += s[i];

		for (const string it : words) {
			int i = 0;
			word[it[0]] = i;
			++i;
		}

		for (int j = 0; j < str.size(); ++j) {
			int i = j, k = 0;
			while (k < len && i < str.size()) {
				if (word.find(str[i]) != word.end())
					word[str[i]] += 1;
				++i, ++k;
			}
			int flag = 0;
			for (auto& it : word) {
				if (it.second == 1)
					++flag;
				else {
					it.second = 0;
					break;
				}
				it.second = 0;
			}
			if (flag == len)
				ans.emplace_back(j * wordLen);
		}
		return ans;
	}
};

int main() {
	//str    = "b  f  f  b  t  f  b  m"
	string s = "barfoothefoobarman";
	//             word =    b     f     t
	//                       0     0     0  
	vector<string>words = { "foo","bar" };
	Solution test;
	auto ans = test.findSubstring(s, words);
	for (auto it : ans)
		cout << it << " ";
	return 0;
}
```









# 31、不会(╥╯^╰╥)











# 32、最長有效括號

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

 

**示例 1：**

```cpp
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```cpp
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**示例 3：**

```cpp
输入：s = ""
输出：0
```

 

**提示：**

- `0 <= s.length <= 3 * 104`
- `s[i]` 为 `'('` 或 `')'`



动态规划：

```cpp

#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

class Solution {
public:
    int longestValidParentheses(string s) {
        int size = s.length();
        vector<int> dp(size, 0);

        int maxVal = 0;
        for (int i = 1; i < size; i++) {
            if (s[i] == ')') {
                if (s[i - 1] == '(') {
                    dp[i] = 2;
                    if (i - 2 >= 0) {
                        dp[i] = dp[i] + dp[i - 2];
                    }
                }
                else if (dp[i - 1] > 0) {
                    if ((i - dp[i - 1] - 1) >= 0 && s[i - dp[i - 1] - 1] == '(') {
                        dp[i] = dp[i - 1] + 2;
                        if ((i - dp[i - 1] - 2) >= 0) {
                            dp[i] = dp[i] + dp[i - dp[i - 1] - 2];
                        }
                    }
                }
            }
            maxVal = max(maxVal, dp[i]);
        }
        return maxVal;
    }
};

int main() {

	return 0;
}
```









# 33、搜索旋转排序数组

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

 

**示例 1：**

```cpp
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**

```cpp
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**

```cpp
输入：nums = [1], target = 0
输出：-1
```

 

**提示：**

- `1 <= nums.length <= 5000`
- `-104 <= nums[i] <= 104`
- `nums` 中的每个值都 **独一无二**
- 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
- `-104 <= target <= 104`





会超时，不知道为什么

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#include<string>
using namespace std;

class Solution {
public:
    int search(vector<int>& nums, int target) {
        int spin = 0;   //旋转位置
        size_t len = nums.size();
        int lift = 0, right = len - 1;
        int dValue = 0;
        //4,5,6,7,0,1,2
        //0 1 2 3 4 5 6
        while (lift < right) {
            int index = (lift + right + 1) >> 1;
            if (nums[index] < nums[0])
                right = index;
            else
                lift = index;
            /*当index的值不在变化（lift和right不在变化）
             *就找到了旋转位置*/
            if (spin != index)
                spin = index;
            else
                break;
        }

        if (target > nums[0]) {
            lift = 0; right = spin - 1;
        }
        else if (target < nums[len - 1]) {
            lift = spin; right = len - 1;
        }
        else
            return (target == nums[0] ? 0 : (len - 1));

        int ans = 0;
        while (lift < right) {
            ans = (lift + right + 1) / 2;
            if (nums[ans] < target)
                lift = ans;
            else if(nums[ans] > target)
                right = ans;
            if (nums[ans] == target)
                return ans;
        }

        if (lift < right)
            return ans;
        else
            return -1;
    }
};

int main() {
    Solution text;
    vector<int>nums = { 4,5,6,7,0,1,2 };
    cout<<text.search(nums, 5);
	return 0;
}
```







# 34、在排序数组中查找元素的第一个和最后一个位置

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

 

**示例 1：**

```cpp
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**

```cpp
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**

```cpp
输入：nums = [], target = 0
输出：[-1,-1]
```

 

**提示：**

- `0 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`
- `nums` 是一个非递减数组
- `-109 <= target <= 109`

广义二分查找：

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#include<string>
using namespace std;

//方法一：
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int len = nums.size();
        int left = 0, right = len - 1;
        //vector<int>ans;
        if (len == 0)
            return{ -1,-1 };
        while (left < right) {
            int index = (left + right) / 2;
            if (nums[index] < target)
                left = index + 1;
            else
                right = index;
        }
        
        int i = 0;
        for (i = right; i < len && i >= 0; ++i) {
            if (nums[i] != target)
                break;
        }

        if (right == i - 1)
            return { right,right };
        else if (nums[right] != target)
            return { -1,-1 };
        else    
            return { right,i - 1 };
    }
};


int main() {
    Solution text;
    vector<int>nums = { 1 };
    for (const auto& it : text.searchRange(nums, 0))
        cout << it << " ";
	return 0;
}
```



双指针：

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#include<string>
using namespace std;

class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int len = nums.size();
        int i = 0, j = 0;
        if (len == 0)
            return{ -1,-1 };
        for (i = 0; i < len; ++i) {
            if (nums[i] == target)
                break;
        }
        if (i > len-1)
            i = len-1;
        if (nums[i] != target)
            return { -1,-1 };

        for (j = len - 1; j >= 0; --j) {
            if (nums[j] == target)
                break;
        }
        return{ i,j };
    }
};

int main() {
    Solution text;
    vector<int>nums = { 1 };
    for (const auto& it : text.searchRange(nums, 0))
        cout << it << " ";
	return 0;
}
```







# 35、搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

 

**示例 1:**

```cpp
输入: nums = [1,3,5,6], target = 5
输出: 2
```

**示例 2:**

```cpp
输入: nums = [1,3,5,6], target = 2
输出: 1
```

**示例 3:**

```cpp
输入: nums = [1,3,5,6], target = 7
输出: 4
```

 

**提示:**

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` 为 **无重复元素** 的 **升序** 排列数组
- `-104 <= target <= 104`





```cpp

#include<iostream>
#include<vector>
#include<algorithm>
#include<string>

using namespace std;

class Solution {
public:
	int searchInsert(vector<int>& nums, int target) {
		int len = nums.size();
		int left = 0, right = len - 1;

		while (left < right) {
			int index = (left + right) / 2;
			if (nums[index] < target)
				left = index + 1;
			else
				right = index;
		}
		if (nums[right] < target)
			return right + 1;
		else
			return right;
	}
};

int main() {
	Solution text;
	vector<int>nums = { 1,3,5,6 };
	cout<<text.searchInsert(nums, 7);
	return 0;
}
```







# 36、有效独数

请你判断一个 `9 x 9` 的数独是否有效。只需要 **根据以下规则** ，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

 

**注意：**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 空白格用 `'.'` 表示。

 

**示例 1：**

![img](D:\Users\suyu\Pictures\Typora-picture\250px-sudoku-by-l2g-20050714svg.png)

```cpp
输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true
```

**示例 2：**

```cpp
输入：board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

 

**提示：**

- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` 是一位数字（`1-9`）或者 `'.'`



```cpp

#include<iostream>
#include<vector>
#include<unordered_map>
#include<algorithm>
using namespace std;


class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        // 二维数组 v，共有 27 行，每行有 128 个元素，初始值都为 0
        int v[27][128] = { 0 };
        //通过数组进行哈希
        // 遍历数独棋盘的行和列
        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                // 判断当前位置是否是数字，并且检查在行、列和九宫格内是否出现重复数字
                if (isdigit(board[i][j]) &&
                    (v[i][board[i][j]]++ || 
                     v[9 + j][board[i][j]]++ || 
                     v[18 + (i / 3) + (j / 3) * 3][board[i][j]]++)) {
                    // 若出现重复数字，则返回 false
                    return false;
                }
            }
        }

        // 若没有出现重复数字，则返回 true
        return true;
    }
};

int main() {

	return 0;
}
```









# 37、唉，太难了







# 38、外观数列



给定一个正整数 `n` ，输出外观数列的第 `n` 项。

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

你可以将其视作是由递归公式定义的数字字符串序列：

- `countAndSay(1) = "1"`
- `countAndSay(n)` 是对 `countAndSay(n-1)` 的描述，然后转换成另一个数字字符串。

前五项如下：

```cpp
1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"
```

要 **描述** 一个数字字符串，首先要将字符串分割为 **最小** 数量的组，每个组都由连续的最多 **相同字符** 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。

例如，数字字符串 `"3322251"` 的描述如下图：

![img](D:\Users\suyu\Pictures\Typora-picture\1629874763-TGmKUh-image.png)



 

**示例 1：**

```cpp
输入：n = 1
输出："1"
解释：这是一个基本样例。
```

**示例 2：**

```cpp
输入：n = 4
输出："1211"
解释：
countAndSay(1) = "1"
countAndSay(2) = 读 "1" = 一 个 1 = "11"
countAndSay(3) = 读 "11" = 二 个 1 = "21"
countAndSay(4) = 读 "21" = 一 个 2 + 一 个 1 = "12" + "11" = "1211"
```

 

**提示：**

- `1 <= n <= 30`



```cpp

#include<iostream>
#include<string>
#include<algorithm>
using namespace std;

class Solution {
public:
    string one_search(int n, string& str) {
        int count = 0;
        string  ans = {};
        char word = {};
        for (int i = 1; i <= str.size(); ++i) {
            if (str[i - 1] == str[i])
                ++count;
            else {
                word = str[i - 1];
                ans += to_string(count + 1) + word;
                count = 0;
            }
        }
        str = ans;
        return ans;
    }

    string countAndSay(int n) {
        string str = "11";
        string ans = {};
        if (n == 1)
            return "1";
        else if (n == 2)
            return "11";
        for (int i = 1; i < n-1; ++i)
            ans = one_search(n, str);
        return ans;
    }
};

int main() {
    Solution text;
    cout << text.countAndSay(2);
	return 0;
}
```







# 39、组合总数

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

 

**示例 1：**

```cpp
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

**示例 2：**

```cpp
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```

**示例 3：**

```cpp
输入: candidates = [2], target = 1
输出: []
```

 

**提示：**

- `1 <= candidates.length <= 30`
- `2 <= candidates[i] <= 40`
- `candidates` 的所有元素 **互不相同**
- `1 <= target <= 40`



回溯+剪枝

```cpp
#include<vector>
#include<iostream>
using namespace std;

class Solution {
public:
    vector<int> cur = {};
    void DFS(int begin, int sum, vector<int>& candidates, 
        int target, vector<vector<int>>& ans) {
        if (sum == target) {
            ans.push_back(cur);
            return;
        }
        if (sum > target) {
            return;
        }

        for (int i = begin; i < candidates.size(); i++) {
            cur.push_back(candidates[i]);
            DFS(i, sum + candidates[i], candidates, target, ans);
            cur.pop_back();
        }
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> ans;
        DFS(0, 0, candidates, target, ans);
        return ans;
    }
};

int main() {
    vector<int>candidates = { 2,3,6,7 };
    Solution text;
    text.combinationSum(candidates, 7);
	return 0;
}
```







# 40、组合总数 2.0

给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

**注意：**解集不能包含重复的组合。 

 

**示例 1:**

```cpp
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

**示例 2:**

```cpp
输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
```

 

**提示:**

- `1 <= candidates.length <= 100`
- `1 <= candidates[i] <= 50`
- `1 <= target <= 30`



```cpp

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
private:
    vector<int> path;
    vector<vector<int>> result;
    int sum = 0, startIndex = 0;

    void backtrackAlgorithm(vector<int>& candidates, int target, int index, vector<bool>& used) {
        // 递归出口
        if (sum == target) {
            result.emplace_back(path);
            return;
        }
        if (sum > target)
            return;

        // 横向遍历 //提前验证一下是否需要去递归？
        for (index; index < candidates.size() && sum + candidates[index] <= target; index++) {
            /*
            剪枝：
            used[i - 1] == true， 说明同一树枝candidates[i - 1]使用过
            used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            */
            //减去重复大小的结点的树
            if (index > 0 && used[index - 1] == false && candidates[index] == candidates[index - 1])
                continue;

            sum += candidates.at(index);
            //获取一组组合
            path.emplace_back(candidates.at(index));
            used.at(index) = true; ++index; //注意used和index的更改顺序

            backtrackAlgorithm(candidates, target, index, used);

            --index; used.at(index) = false;
            sum -= candidates.at(index);    //注意used和index的更改顺序
            path.pop_back();
        }
    }
    //1,1,2,5,6,7,10
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(), false);
        // 对一些空间初始化清空
        path.clear();
        result.clear();
        // 由于要进行剪枝，所以先对candidates排序
        sort(candidates.begin(), candidates.end()); // 默认升序
        backtrackAlgorithm(candidates, target, 0, used);
        return result;
    }
};

int main() {
    Solution test;
    vector<int> candidates{ 10,1,2,7,6,1,5 };
    int target = 0;
    cin >> target;
    auto ans = test.combinationSum2(candidates, target);

    for (auto it : ans) {
        for (auto iu : it) {
            cout << iu << ',';
        }
        cout << '\n';
    }
    system("pause");
    return 0;
}
```







# 41、缺失的第一个正数



给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

 

**示例 1：**

```cpp
输入：nums = [1,2,0]
输出：3
```

**示例 2：**

```cpp
输入：nums = [3,4,-1,1]
输出：2
```

**示例 3：**

```cpp
输入：nums = [7,8,9,11,12]
输出：1
```

 

**提示：**

- `1 <= nums.length <= 5 * 105`
- `-231 <= nums[i] <= 231 - 1`



```cpp

//原地哈希
#include<iostream>
#include<algorithm>
#include<string>
#include<vector>
#include<math.h>
using namespace std;

class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int len = (int)nums.size();
        for (int i = 0; i < len; ++i) {
            //由于交换后的数依然需要进行排队，所以用while再一次去判断交换后的数
            while (nums[i]!=i+i) {
                //如果超出哈希表的边界或者已经在对应的哈希表位置就不需要进行排队
                if (nums[i] <= 0 || nums[i] > len || nums[i] == nums[nums[i] - 1])
                    break;
                /*int idx = nums[i] - 1;
                nums[i] = nums[idx];
                nums[idx] = idx + 1;*/
                swap(nums[i], nums[nums[i] - 1]);
            }
        }
        for (int i = 0; i < len; ++i) {
            if (nums[i] != (i + 1))
                return i + 1;
        }
        return (len+1);
    }
};
//3,4,-1,1

int main() {

    Solution text;
    vector<int>nums{ -1,5,1,2 };
    int ans = text.firstMissingPositive(nums);
    cout << ans << '\n';
    system("pause");
    return 0;
}
```

