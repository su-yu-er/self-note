---

---

# 一、递归算法

1、如何思考二叉树相关问题?
2、为什么需要使用递归?
3、为什么这样写就一定能算 出正确答案?
4、计算机是怎么执行递归的?
5、另一种递归思路



如图：求二叉树的深度

![image-20231026193057870](D:\Users\suyu\Pictures\Typora-picture\image-20231026193057870.png)



不要一开始就陷入细节
而是思考整棵树与其左右子树的关系
整棵树的最大深度 = max (左子树的最大深度，右子树的最大深度) + 1

<img src="D:\Users\suyu\Pictures\Typora-picture\image-20231026193206593.png" alt="image-20231026193206593" style="zoom: 67%;" />



原问题：计算整棵树的最大深度
子问题：计算左/右子树的最大深度
**子问题与原问题是相似的**

类比循环，执行的代码也应该是相同的
但子问题需要把计算结果返给上一级问题
这更适合用**递归**实现

<img src="D:\Users\suyu\Pictures\Typora-picture\image-20231026193414295.png" alt="image-20231026193414295" style="zoom: 67%;" />



由于子问题的规模比原问题小不断递下去，总会有个尽头即递归的边界条件( base case )
直接返回它的答案 ( 归 ) 

<img src="D:\Users\suyu\Pictures\Typora-picture\image-20231026193554398.png" alt="image-20231026193554398" style="zoom:67%;" />



递归的数学支撑来自数学归纳法









# 二、动态规划（DP）

给一个数组如： 

`arr={1,2,4,1,7,8,3}` 求不相邻的数之和的最大值

![image-20231027172451606](D:\Users\suyu\Pictures\Typora-picture\image-20231027172451606.png)

 

```cpp
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

//递归的动态规划（一般动态规划不用递归）
int rec_opt(const int arr[], int i) {
	if (i == 0)
		return arr[0];
	else if (i == 1)
		return max(arr[0], arr[i]);
	else {
		int A = rec_opt(arr, i - 2) + arr[i];
		int B = rec_opt(arr, i - 1);
		return max(A, B);
	}
}

//动态规划
int dp_opt(const int arr[],int len) {
	
	vector<int>opt(len, 0);
	opt[0] = arr[0];
	opt[1] = max(arr[1],arr[0]);
	//通过这个循环去模拟了递归的过程
	for (int j = 2; j < len; ++j) {
		int A = opt[j - 2] + arr[j];
		int B = opt[j - 1];
		opt[j] = max(A, B);
	}
	return opt[len - 1];
}

int main() {

	int arr[] = { 1,2,4,1,7,8,3 };
	int i = 0;
	int len = sizeof(arr) / sizeof(arr[0]);
	//cout << len << endl;
	cout << dp_opt(arr, len);

	return 0;
}
```









# 三、DFS剪枝

《代码随想录》算法视频公开课：回溯算法中的去重，树层去重树枝去重，你弄清楚了没？| LeetCode:40.组合总和II（https://leetcode.cn/link/?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV12V4y1V73A），相信结合视频再看本篇题解，更有助于大家对本题的理解。

## 思路

这道题目和39.组合总和如下区别：

本题candidates 中的每个数字在每个组合中只能使用一次。
本题数组candidates的元素是有重复的，而39.组合总和是无重复元素的数组candidates
最后本题和39.组合总和要求一样，解集不能包含重复的组合。

本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合。

一些同学可能想了：我把所有组合求出来，再用set或者map去重，这么做很容易超时！

所以要在搜索的过程中就去掉重复组合。

很多同学在去重的问题上想不明白，其实很多题解也没有讲清楚，反正代码是能过的，感觉是那么回事，稀里糊涂的先把题目过了。

这个去重为什么很难理解呢，所谓去重，其实就是使用过的元素不能重复选取。 这么一说好像很简单！

都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。

那么问题来了，我们是要同一树层上使用过，还是同一树枝上使用过呢？

回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。

所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。

为了理解去重我们来举一个例子，candidates = [1, 1, 2], target = 3，（方便起见candidates已经排序了）

==**强调一下，树层去重的话，需要对数组排序！**==

选择过程树形结构如图所示：

![image.png](D:\Users\suyu\Pictures\Typora-picture\1672110919-KHhJDC-image.png)

可以看到图中，每个节点相对于 39.组合总和我多加了used数组，这个used数组下面会重点介绍。



## 回溯三部曲

​	**递归函数参数**
与39.组合总和套路相同，此题还需要加一个bool型数组used，用来记录同一树枝上的元素是否使用过。

这个集合去重的重任就是used来完成的。

代码如下：

```cpp
vector<vector<int>> result; // 存放组合集合
vector<int> path;           // 符合条件的组合
void backtracking(vector<int>& candidates, int target, int sum, int startIndex, vector<bool>& used) {
```

​	**递归终止条件**
与39.组合总和相同，终止条件为 sum > target 和 sum == target。

代码如下：

```cpp
if (sum > target) { // 这个条件其实可以省略
    return;
}
if (sum == target) {
    result.push_back(path);
    return;
}
```

`sum > target` 这个条件其实可以省略，因为在递归单层遍历的时候，会有剪枝的操作，下面会介绍到。

单层搜索的逻辑
这里与39.组合总和最大的不同就是要去重了。

前面我们提到：要去重的是“同一树层上的使用过”，如何判断同一树层上元素（相同的元素）是否使用过了呢。

如果`candidates[i] == candidates[i - 1]` 并且 `used[i - 1] == false`，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]。

此时for循环里就应该做continue的操作。

这块比较抽象，如图：

![image.png](D:\Users\suyu\Pictures\Typora-picture\1672110999-tOgJKW-image.png)

我在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下：

- used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
- used[i - 1] == false，说明同一树层candidates[i - 1]使用过

可能有的录友想，为什么 used[i - 1] == false 就是同一树层呢，**因为同一树层，used[i - 1] == false 才能表示，当前取的 candidates[i] 是从 candidates[i - 1] 回溯而来的**。

而 used[i - 1] == true，说明是进入下一层递归，去下一个数，所以是树枝上，如图所示：

![image.png](D:\Users\suyu\Pictures\Typora-picture\1672111042-cNXIfI-image.png)

这块去重的逻辑很抽象，网上搜的题解基本没有能讲清楚的，如果大家之前思考过这个问题或者刷过这道题目，看到这里一定会感觉通透了很多！

```cpp
for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
    // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
    // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
    // 要对同一树层使用过的元素进行跳过
    if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {
        continue;
    }
    sum += candidates[i];
    path.push_back(candidates[i]);
    used[i] = true;
    backtracking(candidates, target, sum, i + 1, used); // 和39.组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次
    used[i] = false;
    sum -= candidates[i];
    path.pop_back();
}
```



回溯三部曲分析完了，整体C++代码如下：

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex, vector<bool>& used) {
        if (sum == target) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 要对同一树层使用过的元素进行跳过
            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {
                continue;
            }
            sum += candidates[i];
            path.push_back(candidates[i]);
            used[i] = true;
            backtracking(candidates, target, sum, i + 1, used); // 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次
            used[i] = false;
            sum -= candidates[i];
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(), false);
        path.clear();
        result.clear();
        // 首先把给candidates排序，让其相同的元素都挨在一起。
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0, used);
        return result;
    }
};
```



## 补充

这里直接用startIndex来去重也是可以的， 就不用used数组了。

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum == target) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            // 要对同一树层使用过的元素进行跳过
            if (i > startIndex && candidates[i] == candidates[i - 1]) {
                continue;
            }
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i + 1); // 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次
            sum -= candidates[i];
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        path.clear();
        result.clear();
        // 首先把给candidates排序，让其相同的元素都挨在一起。
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0);
        return result;
    }
};
```

