



```c++
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
#include<map>
#include<random>
#include<numeric>
#include<time.h>

using namespace std;

class HuffmanTree
{
public:
    //用于存储哈夫曼结点
    vector<HuffmanTree>Huf;

    string m_point;
    int m_weight = 0;		//权重
    int m_parent = 0, m_lch = 0, m_rch = 0;


    //哈夫曼树建立
    void CreatHuffmanTree(vector<HuffmanTree>& Huf, const int n);

    //哈夫曼编码产生
    void Show_Huffman_coding(const vector<HuffmanTree>& Huf, const int n);

	//private:
    //获取哈夫曼中的最小值和次小值的下标
    void Select(vector<HuffmanTree>& Huf, int n, int& s1, int& s2);
};

//获取哈夫曼中的最小值和次小值的下标
void HuffmanTree::Select(vector<HuffmanTree>& Huf, int n, int& s1, int& s2)
{
    Huf[0].m_weight = 1000000;
    s1 = 0, s2 = 0;
    //a6,b4,c1,d7,e2
    for (int i = 1; i <= n; ++i){
        //首先排除有parent的结点
        if (Huf[i].m_parent == 0){
            if (Huf[i].m_weight < Huf[s1].m_weight){
                s2 = s1;
                s1 = i;
            }
            else if (Huf[i].m_weight < Huf[s2].m_weight)
                s2 = i;
        }
    }
    //交换s1和s2的值，保持s1<s2
    if (Huf[s2].m_weight < Huf[s1].m_weight)
        swap(s2, s1);
}


//生成哈夫曼树
void HuffmanTree::CreatHuffmanTree(vector<HuffmanTree>& Huf, const int n)
{
    int m = n * 2 - 1;    //数组共2n-1个元素
    Huf.resize(m + 1);	  //开辟空间

    if (n <= 1)        //
        return;

    //初始化HuffmanTree结点值(从下标为1到下标为n)
    for (auto it = Huf.begin() + 1; it <= Huf.begin() + n; ++it){
        //初始化 parent，lch，rch
        it->m_parent=0, it->m_lch = 0, it->m_rch = 0;
        string point;
        int weight = 0;

        cout << "请输入结点名称：";
        cin >> point;
        it->m_point = point;

        cout << "请输入结点权重：";
        cin >> weight;
        it->m_weight = weight;
        cout << endl;
    }
    
   /* int s1 = 0, s2 = 0;
    Select(Huf, n, s1, s2);
    cout << "s1:" << s1 << " s1.weight:" << Huf[s1].m_weight << endl;
    cout << "s2:" << s2 << " s2.weight:" << Huf[s2].m_weight << endl;*/

    //合并产生n-1个结点 构造Huffman树
    for (int i = n + 1; i <= m; ++i){
        int s1 = 1000000, s2 = 1000000;
        Select(Huf, i - 1, s1, s2);
        
		//构建哈夫曼树
        Huf[s1].m_parent = i, Huf[s2].m_parent = i;
        //i的权值为左右孩子权值之和
        Huf[i].m_weight = Huf[s1].m_weight + Huf[s2].m_weight;
        //s1,s2分 别作为i的左右孩子
        Huf[i].m_lch = s1, Huf[i].m_rch = s2;
    }
}


//哈夫曼编码产生
void HuffmanTree::Show_Huffman_coding(const vector<HuffmanTree>& Huf, const int n)
{
    cout << "point" << " weight" << " parent" << "    lch" << "     rch" << endl;
    for (auto it = Huf.begin() + 1; it < Huf.end(); ++it){
        cout << "  " <<
            it->m_point << "   \t" << 
            it->m_weight << "  \t" << 
            it->m_parent << "  \t" << 
            it->m_lch << "   \t" << 
            it->m_rch << "   \t" << endl;
    }

    map<string, string>Huf_coding;
    for (int i = 1; i <= n; ++i){
        int ch = i;
        int j = i;
        string coding = { 0 };
        
        while (Huf[ch].m_parent != 0){
            int j = Huf[ch].m_parent;
            if (Huf[j].m_lch == ch)
                coding += "0";

            else if (Huf[j].m_rch == ch)
                coding += "1";

            ch = j;
        }
        /*如果不将ch置为i值，则ch一直为根节点，
        又因为map的key值不能相同，所以之后的编码无法插入map中。*/
        ch = i;
        Huf_coding.insert(make_pair(Huf[ch].m_point, coding));
    }
	//也可以反向遍历就不需要翻转
    for (auto it = Huf_coding.begin(); it != Huf_coding.end(); ++it){
        reverse(it->second.begin(), it->second.end());
        cout << (it->first) << ": " << it->second << endl;
    }
}

int main()
{
    HuffmanTree huft;
    int n = 5;
    huft.CreatHuffmanTree(huft.Huf,n);
    huft.Show_Huffman_coding(huft.Huf, n);

    return 0;
}
```

