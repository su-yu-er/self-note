# 1、C++之运算符重载(前置++和后置++)

在学习C++过程中我们会发现，对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符，理由是 前置自增 (++i) 通常要比后置自增 (i++) 效率更高。

**在《C专家编程》中也讲到:**

***++a表示取a的地址，增加它的内容，然后把值放在寄存器中；***

**a++表示取a的地址，把它的值装入寄存器，然后增加内存中的a的值；**

例如:对于int类型变量，在进行前置++的时候，是会将i进行加1，然后返回i的引用。而i++是先创建一个i的副本，然后在对i进行加1，最后返回i的副本的值

对于效率不同的问题，让我们从运算符重载的角度来探讨一下!

假设有一个INT类，我们重载了前置++和后置++两个操作符

代码如下:

```cpp
class INT
{
private:
	int value;
public:

	void Print()
	{
		cout << " " << value << endl;
	}
	INT(int v=0) :value(v)
	{
		cout << "创建对象 " << this << endl;
	}
	~INT()
	{
		cout << "销毁对象 " << this << endl;
	}
	INT(const INT& mc) :value(mc.value)
	{
		cout << "拷贝构造对象 " << this << endl;
	}
	INT& operator++() //前置++
	{
		this->value += 1;
		return *this;
	}
	const INT  operator++(int)  //后置++
	{
		INT od = *this;
		++*this;
		return od;
		//return INT(this->value++);
	}
    //重载了一个整型强转
	operator int const() { return value; }
};
```

从上述代码，我们可以看出前置++和后置++，有3点不同：

1. 返回类型不同
2. 形参不同
3. 效率不同

**1.返回值类型的区别**

前置++的返回类型是INT&，后置++的返回类型const INT。这意味着，前置++返回的是左值，后置++返回的是右值。 

左值和右值，决定了前置++和后置++的用法

```c++
int main()     
{ 
 INT a;     

 (a++)++;  //编译错误     
 ++(a++);  //编译错误     
 a++ = 1;   //编译错误     
 (++a)++;  //OK     
 ++(++a);  //OK     
 ++a = 1;   //OK     
}    
```



++的类型是const INT，自然不能对它进行前置++、后置++、赋值等操作。

++a的类型是INT&，当然可以对它进行前置++、后置++、赋值等操作

**a++的返回类型为什么要是const对象呢？**

有两个原因：

​		1、如果不是const对象，a(++)++这样的表达式就可以通过编译。但是，其效果却违反了我们的直觉 。a其实只增加了1，因为第二次自增作用在一个临时对象上。

​		2、另外，对于内置类型，(i++)++这样的表达式是不能通过编译的。自定义类型的操作符重载，应该与内置类型保持行为一致 。

​		a++的返回类型如果改成非const对象，肯定能通过编译，但是我们最好不要这样做。



**++a的返回类型为什么是引用呢？**

这样做的原因应该就是：与内置类型的行为保持一致。前置++返回的总是被自增的对象本身。因此，++(++a)的效果就是a被自增两次。

**2.形参的区别**

前置++没有形参，而后置++有一个int形参，但是该形参也没有被用到。很奇怪，难道有什么特殊的用意？

其实也没有特殊的用意，只是为了绕过语法的限制。

前置++与后置++的操作符重载函数，函数原型必须不同。否则就违反了“重载函数必须拥有不同的函数原型”的语法规定。

虽然前置++与后置++的返回类型不同，但是返回类型不属于函数原型。为了绕过语法限制，只好给后置++增加了一个int形参。

原因就是这么简单，真的没其他特殊用意。其实，给前置++增加形参也可以；增加一个double形参而不是int形参，也可以。只是，当时就这么决定了。

**3.效率的区别**

如果不需要返回自增之前的值，那么前置++和后置++的计算效果都一样。但是，我们仍然应该优先使用前置++，尤其是对于用户自定义类型的自增操作。

前置++的效率更高，理由是：后置++会生成临时对象。

从INT的后置++的代码实现也可以看出这一点。



```c++
const INT  operator++(int)  //后置++
	{
		INT old = *this;
		++*this;  //利用前置++
		return old;
		//return INT(this->value++);  //此方法也可以
	}
```

很明显，old是一个临时对象，会造成一次构造函数和一次析构函数的额外开销。虽然，编译器在某些情况下可以优化掉这些开销。但是，我们最好不要依赖编译器的行为。

**我们编写主函数编译之后就能很容易的发现其效率的不同：**

**++i 创建一对象，销毁一对象**

```c++
int main()
{
	for (INT i = 0; i < 5;++i)
	{
		i.Print();
	}
}
```



**i++ 后置++返回的操作之前的一个副本值，需要不断的拷贝和销毁***

```c++
int main()
{
	for (INT i = 0; i < 5;i++)
	{
		i.Print();
	}
}
```



<img src="https://img-blog.csdnimg.cn/37ad59c35ea8437dbaf9214f1cc998f7.png" alt="img" style="zoom:50%;" />

**总结: 在非内置类型的时候，尽量使用前置++，因为效率高（后置自增，效率低）**







# 2、free函数和malloc函数的分析

​		**对于free函数，它释放了由malloc函数所分配的内存空间。那么，如何理解此处的"释放"呢?实际上malloc函数就是给指针一个合法的地址，并且该地址指向一个合法的内存空间。而对指针进行free后，之前分配的内存空间就"自由了"，即该内存空间又可以重新被操作系统所分配(既可能分配给本程序，也可能分配给其他程序)；而free后的指针仍然存在，其值还是刚刚分配的内存空间的地址，并不是0(并不是NULL)。所以free之后，通常要手动的将指针设置为NULL。**



​		**在使用[struct]来定义并声明一个变量时，将会自动划分出一个连续的储存空间（虽然根据某些对齐原则会出现内存间隙，但是大体上来说还是连续的）**

​		**free()只能释放指针所指向的那片内存。也就是说，当出现不连续的空间时，free()函数不能将空间完全释放。**







# 3、assert详解

我一直以为assert仅仅是个报错函数，事实上，它居然是个宏，并且作用并非“报错”。

　　在经过对其进行一定了解之后，对其作用及用法有了一定的了解，assert()的用法像是一种“契约式编程”，在我的理解中，其表达的意思就是，程序在我的假设条件下，能够正常良好的运作，其实就相当于一个if语句：

```c
//当assert中的条件不成立时就会报错。
assert(条件);
if(假设成立)
{
     程序正常运行；
}
else
{
      报错&&终止程序！（避免由程序运行引起更大的错误）  
}
```

　　但是这样写的话，就会有无数个if语句，甚至会出现，一个if语句的括号从文件头到文件尾，并且大多数情况下，我们要进行验证的假设，只是属于偶然性事件，又或者我们仅仅想测试一下，一些最坏情况是否发生，所以这里有了assert().

　　　assert宏的原型定义在assert.h中，其作用是如果它的条件返回错误，则终止程序执行. 

```c
1 #include "assert.h" 
2 void assert( int expression );
```

　　assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息,然后通过调用 abort 来终止程序运行。
 使用assert的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。 
　　在调试结束后，可以通过在包含#include 的语句之前插入 #define NDEBUG 来禁用assert调用，示例代码如下： 

```c
1 #include 
2 #define NDEBUG 
3 #include
```

 　用法总结与注意事项： 

　　（1）、在函数开始处检验传入参数的合法性 
　　如: 

```c
 1 int resetBufferSize(int nNewSize) 
 2 { 
 3 //功能:改变缓冲区大小, 
 4 //参数:nNewSize 缓冲区新长度 
 5 //返回值:缓冲区当前长度 
 6 //说明:保持原信息内容不变 nNewSize<=0表示清除缓冲区 
 7 assert(nNewSize >= 0); 
 8 assert(nNewSize <= MAX_BUFFER_SIZE); 
 9  
10 ... 
11 } 
```

　　（2）、每个assert只检验一个条件,因为同时检验多个条件时,如果断言失败,无法直观的判断是哪个条件失败 
　　 
　　不好:

​		 assert(nOffset>=0 && nOffset+nSize<=m_nInfomationSize);  
　　好: 

​				assert(nOffset >= 0); 
　　　　 assert(nOffset+nSize <= m_nInfomationSize); 
　 
　　（3）、不能使用改变环境的语句,因为assert只在DEBUG个生效,如果这么做,会使用程序在真正运行时遇到问题 
　　错误: assert(i++ < 100) 
　　　　　这是因为如果出错，比如在执行之前i=100,那么这条语句就不会执行，那么i++这条命令就没有执行。 
　　正确: assert(i < 100) 
　　 　 i++; 
　 
　　（4）、assert和后面的语句应空一行,以形成逻辑和视觉上的一致感 
　　 
　　（5）、有的地方,assert不能代替条件过滤 　 
　　 
　　程序一般分为Debug 版本和Release 版本，Debug 版本用于内部调试，Release 版本发行给用户使用。**断言assert 是仅在Debug 版本起作用的宏，它用于检查“不应该”发生的情况**。以下是一个内存复制程序，在运行过程中，如果assert 的参数为假，那么程序就会中止（一般地还会出现提示对话，说明在什么地方引发了assert）。 

**以下是使用断言的几个原则**： 
　　 
　　（1）使用断言捕捉不应该发生的非法情况。不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且是一定要作出处理的。 
　　 
　　（2）使用断言对函数的参数进行确认。 
　　 
　　（3）在编写函数时，要进行反复的考查，并且自问：“我打算做哪些假定？”一旦确定了的假定，就要使用断言对假定进行检查。 
　　 
　　（4）一般教科书都鼓励程序员们进行防错性的程序设计，但要记住这种编程风格会隐瞒错误。当进行防错性编程时，如果“不可能发生”的事情的确发生了，则要使用断言进行报警。 

　　ASSERT ()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。 

**ASSERT只有在Debug版本中才有效，如果编译为Release版本则被忽略。** 